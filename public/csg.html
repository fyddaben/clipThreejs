<!DOCTYPE html>

<html>

<head>

<script type="text/javascript" src="three.min.js"></script>
<script type="text/javascript" src="three-csg.js"></script>
<script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>

<script type="text/javascript" src="OrbitControls.js"></script>

<style type="text/css">
	html, body {
		margin: 0;
		padding: 0;
		overflow: hidden;
	}
	#viewport{
		width: 800px;
		height: 800px;
	}
	.btn{
		position: absolute;
		right: 100px;
		top: 50px;
		width: 100px;
		height: 40px;
		background: red;
		color: #fff;
		text-align: center;
		line-height: 40px;
		cursor: pointer;
	}
	.container{
		position: relative;
	}
	.canvas-wrap{
		position: absolute;
		width: 1px;
		height: 1px;
		left: 0;
		top: 0;
		overflow: hidden;
	}
	.container.show-canvas .canvas-wrap{
		width: 800px;
		height: 800px;
	}
</style>

</head>

<body>
	<div class="container J_container">
		<div id="viewport"></div>
		<div class="canvas-wrap">
			<canvas width='800' height='800' id='J_canvas'></canvas>
		</div>
	</div>
	
	<div class="btn">开始绘画</div>
	<script type="text/javascript">
		var renderer, scene, camera, light, 
		result, orbitControls, offsetX, offsetY, wireMaterial, boxMesh,
		projector, hNear, wNear, canvas, context,isDrawing, canvasPoint,
		container, viewWidth, viewHeight;
		var isCanRotate = true
		
		
		window.onload = function() {

			$('.btn').click(()=> {
				isCanRotate = false
				$('.J_container').addClass('show-canvas')
			})
			
			container = document.getElementById('viewport')
			viewWidth = container.clientWidth
			viewHeight = container.clientHeight

			renderer = new THREE.WebGLRenderer({antialias: true});
			renderer.setSize( viewWidth, viewHeight);
			container.appendChild(renderer.domElement);
		
			scene = new THREE.Scene();

			scene.add(new THREE.AmbientLight(0x404040));
			light = new THREE.DirectionalLight( 0xffffff );
			light.position.set( 1, 1, 15 ).normalize();
			scene.add( light );
		
			camera = new THREE.PerspectiveCamera(
				35,
				viewWidth / viewHeight,
				1,
				1000
			);
			camera.position.set( 0, 0, 15 );
			camera.lookAt( scene.position );
			scene.add( camera );
			wireMaterial = new THREE.MeshBasicMaterial({wireframe: true});
				
			orbitControls = new THREE.OrbitControls(camera, renderer.domElement, result);
			orbitControls.enableDamping = true;
			console.log(getNearPlaneWidth().w, getNearPlaneWidth().h)
			
			// 初始化

			// 获取画布已经绘图上下文
			canvas = document.getElementById("J_canvas");
			canvas.width = viewWidth
			canvas.height = viewHeight
			context = canvas.getContext("2d");
			// 设置线条颜色
			context.strokeStyle = 'red';
			context.lineWidth = 1;
			context.lineJoin = 'round';
			context.lineCap = 'round';
			context.fillStyle= "rgba(100, 40, 40, 0.3)";

			// 画布添加鼠标事件
			canvas.addEventListener('mousedown', startDrawing, false);
			canvas.addEventListener('mousemove', draw, false);
			canvas.addEventListener('mouseup', stopDrawing, false);
			
			isDrawing = false;
			
			// Example #1 - Cube (mesh) subtract Sphere (mesh)
			(function() {
				var start_time = (new Date()).getTime();
				var cube_geometry = new THREE.BoxBufferGeometry( 3, 3, 3 );
				const normalMaterial = new THREE.MeshNormalMaterial();
				var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
				
				var cube_mesh = new THREE.Mesh( cube_geometry, wireMaterial );
				cube_mesh.position.x = 0;
			
			
				boxMesh = cube_mesh
				scene.add( cube_mesh );
				
			})();

			// 获取近面的宽度，高度
			function getNearPlaneWidth() {
				var cameraposition = camera.position
				var distance = Math.sqrt(Math.pow(cameraposition.x, 2) + Math.pow(cameraposition.y, 2) + Math.pow(cameraposition.z, 2))
				
				var vFOV = THREE.Math.degToRad( camera.fov ); // convert vertical fov to radians

				var dheight = 2 * Math.tan( vFOV / 2 ) * distance; // visible height

				var dwidth = dheight * camera.aspect; 
				return {
					w: dwidth,
					h: dheight
				}
			}
			
			// 把canvas点的坐标，转为shape可用的坐标
			function turnNum(point) {
				var newPoint = []
				var w = getNearPlaneWidth().w
				var h = getNearPlaneWidth().h
				point.map((p, i)=> {
					var x = p[0] / viewWidth * 2 - 1;
					var y = -p[1] / viewHeight * 2 + 1;
					newPoint.push([x*(w/2), y*(h/2)])
				})
				isCanRotate = true
				drawShape(newPoint)
			}
			// 画图像
			
			function drawShape(point) {
				var x = 0, y = 0;
				var heartShape = new THREE.Shape();
				point.map((p, i)=> {
					if (i == 0) {
						heartShape.moveTo(p[0], p[1])
					} else {
						heartShape.lineTo(p[0], p[1])
					}
				})
				// 假设比例30就够了
				var cameraposition = camera.position
				// 把这个被删减者，放到原点后面的.3的位置
				var target = [-cameraposition.x * .3, -cameraposition.y * .3, -cameraposition.z * .3]
				// 计算被删减者的长度
				var depth = 2 * Math.sqrt(Math.pow(target[0], 2) + Math.pow(target[1], 2) + Math.pow(target[2], 2))
				//console.log(depth, 'wwww')
				var extrudeSettings = {
						steps: 10,
						depth: depth,
						bevelEnabled: false,
						bevelThickness: 1,
						bevelSize: 1,
						bevelSegments: 1
				};
				const normalMaterial = new THREE.MeshNormalMaterial();
				var Sgeometry = new THREE.ExtrudeBufferGeometry( heartShape, extrudeSettings );
				var focalPoint = new THREE.Vector3().copy(cameraposition)
				// 调整转向
				Sgeometry.lookAt(focalPoint);
				// 再移动到相机的点与当前点的中间
				
				
				Sgeometry.translate(target[0], target[1], target[2]);
				
				var Smesh = new THREE.Mesh( Sgeometry,  wireMaterial) ;
				
				// 进行切割
				//const box3 = threecsg.subtract(cube_mesh, Smesh, normalMaterial);

				const box3 = threecsg.subtract(boxMesh, Smesh, normalMaterial);
				//box3.quaternion.set(0, 0, 0, 1).normalize();
				scene.add( Smesh );
				scene.add( box3 );
			}

			function startDrawing(evt) {
				isDrawing = true
				var { x, y } = getPos(evt)
				canvasPoint = []
				canvasPoint.push([x, y])
			}

			function stopDrawing(evt) {
				isDrawing = false
				// 移除画布
				$('.J_container').removeClass('show-canvas')
				
				turnNum(canvasPoint)
			}
			function draw(evt) {
				if (!isDrawing) return;
				evt.preventDefault();
				evt.stopPropagation();
				const { x, y } = getPos(evt);
				canvasPoint.push([x, y])
			}
			function getPos(evt) {
				var top = document.getElementById('J_canvas').offsetTop
				var left = document.getElementById('J_canvas').offsetLeft
				return {
					x: evt.clientX - left,
					y: evt.clientY - top
				}
			}
			function calcOffsets(){
				var rect = container.getBoundingClientRect();                                
				offsetX = rect.left;
				offsetY = rect.top;
			}
			function getFactorPos( val, factor, step ){
					return step / factor * val;                
			}
			// 点的位置
			var  pointPoition = null
			var isStartDrag = false
			
			function drawLine() {
				context.beginPath()
				canvasPoint.map((v, b)=> {
					if (b == 0) {
						context.moveTo(v[0], v[1])
					} else {
						context.lineTo(v[0], v[1])
					}
				})
				context.lineTo(canvasPoint[0][0], canvasPoint[0][1])
				context.stroke()
				context.fill()
			}
		
		
			(function render() {
				if (isCanRotate) {
					orbitControls.update()
				}
				if (isDrawing) {
					context.clearRect(0, 0, canvas.width, canvas.height)
					drawLine()
				}
				requestAnimationFrame( render );
				light.position.copy(camera.position);
				
				renderer.render(scene, camera);
			})();
		}
		</script>
</body>

</html>
